import numpy as np
import pandas as pd
import logging

class MetricGroup():
    # class-level constants
    CONFIG_SETTINGS = "config_settings"
    
    CONFIG_AGGREGATION_TYPES = "aggtypes"
    CONFIG_GEOLEVELS = "geolevels"
    CONFIG_METRICS = "metrics"
    
    CONFIG_DATA_PAIR = "data_pair"
    CONFIG_QUANTILES = "quantiles"
    
    RUNTIME_IN_SECONDS = "runtime_in_seconds"
    
    RESULTS = "results"
    
    METRIC_GROUP_NAME = "metric_group"
    
    GEOLEVEL_AXIS = 0
    AGGTYPE_AXIS = 1
    METRIC_AXIS = 2
    
    def __init__(self, emdict):
        """
        Constructor for MetricGroup
        Inputs:
            emdict (dict): an error metrics dictionary
        Notes:
            Error metrics dictionaries must have the following fields:
                metric_group: str
                runtime_in_seconds: float
                results: dict
                    a key-value pair for each Geolevel.Aggtype.Metric
                config_settings: dict
                    geolevels: list
                    aggtypes: list
                    metrics: list
                    data_pair: list
                    quantiles: list
        """
        self.emdict = emdict
        
        self.config_settings = self.emdict[self.CONFIG_SETTINGS]
        self.aggtypes = self.config_settings[self.CONFIG_AGGREGATION_TYPES]
        self.geolevels = self.config_settings[self.CONFIG_GEOLEVELS]
        self.metrics = self.config_settings[self.CONFIG_METRICS]
        
        self.data_pair = self.config_settings[self.CONFIG_DATA_PAIR]
        self.quantiles = self.config_settings[self.CONFIG_QUANTILES]
        
        self.results = self.emdict[self.RESULTS]
        
        self.runtime_in_seconds = self.emdict[self.RUNTIME_IN_SECONDS]
        
        self.metric_group_name = self.emdict[self.METRIC_GROUP_NAME]
        
        self.resma = self.__createResma()
    
    def __repr__(self):
        return "\nName:      {}\nGeolevels: {}\nAggtypes:  {}\nMetrics:   {}\nData Pair: {}\nQuantiles: {}\nResults:   See getResma() or getDF()\nRuntime:   {} seconds\n\n".format(self.metric_group_name, 
                          ", ".join(self.geolevels),
                          ", ".join(self.aggtypes),
                          ", ".join(self.metrics),
                          ", ".join(self.data_pair),
                          ", ".join([str(q) for q in self.quantiles]),
                          self.runtime_in_seconds )
    
    def getOriginalDict(self):
        return self.emdict
    
    def getRuntimeInSeconds(self):
        return self.runtime_in_seconds
    
    def getName(self):
        return self.metric_group_name
    
    def getResultsAsDict(self):
        return self.results
    
    def getResma(self):
        return self.resma
    
    def getSettings(self):
        return self.config_settings
    
    def __createResma(self):
        shape = (len(self.geolevels), len(self.aggtypes), len(self.metrics))
        keyma = np.zeros(shape, dtype="object")
        for g,a,m in np.ndindex(shape):
            geo = self.geolevels[g]
            agg = self.aggtypes[a]
            met = self.metrics[m]
            key = "{}.{}.{}".format(geo, agg, met)
            keyma[(g,a,m)] = (key, self.results[key])
        
        return Resma(keyma)
    
    def getDF(self):
        return self.resma.toDF()
    



class Resma():
    """
    Resma (Results Multiarray) is a wrapper class for the "results" numpy array
    generated by the (geolevels, aggtypes, metrics) tuples/dictionary created
    by the DAS Error Metrics class and stored within the Metric Group object.
    """
    
    AXIS_MAP = { "geolevels": 0,
                 "geolevel" : 0,
                 "g"        : 0,
                 
                 "aggtypes" : 1,
                 "aggtype"  : 1,
                 "a"        : 1,
                 
                 "metrics"  : 2,
                 "metric"   : 2,
                 "m"        : 2
        }
    
    def __init__(self, array):
        self.array = array
        self.shape = self.array.shape
        self.geolevels = np.array([x[0].split(".")[0] for x in self.array[:,0,0]])
        self.aggtypes  = np.array([x[0].split(".")[1] for x in self.array[0,:,0]])
        self.metrics   = np.array([x[0].split(".")[2] for x in self.array[0,0,:]])
        self.keys = np.array([x[0] for x in self.array.flatten()])
        self.values = np.array([x[1] for x in self.array.flatten()])
    
    def __repr__(self):
        return "Geolevels: {}\nAggtypes: {}\nMetrics: {}\n".format(self.geolevels, self.aggtypes, self.metrics)
    
    def subset(self, geolevels=None, aggtypes=None, metrics=None):
        sl = [range(x) for x in self.shape]
        
        if geolevels is not None:
            sl[0] = [self.geolevels.tolist().index(x) if type(x) is str else x for x in geolevels]
        
        if aggtypes is not None:
            sl[1] = [self.aggtypes.tolist().index(x) if type(x) is str else x for x in aggtypes]
        
        if metrics is not None:
            sl[2] = [self.metrics.tolist().index(x) if type(x) is str else x for x in metrics]
        
        sub = self.array[np.ix_(*sl)]
        return Resma(sub)
    
    def split(self, axis):
        if isinstance(axis, tuple):
            axis = list(axis)
        elif isinstance(axis, int) or isinstance(axis, str):
            axis = [axis]
        
        axis = [self.AXIS_MAP[x] if type(x) is str else x for x in axis]
        
        splits = [self.array]
        for a in axis:
            ax_splits = []
            ax_splits += splits
            splits = []
            for array in ax_splits:
                splits += self.__splitArray(array, axis=a)
            
        splits = [Resma(x) for x in splits]
        return splits
    
    def __splitArray(self, array, axis):
        splits = []
        sl = [range(x) for x in array.shape]
        for i in range(array.shape[axis]):
            sl[axis] = [i]
            sub = array[np.ix_(*sl)]
            splits.append(sub)
        
        return splits
    
    def squeeze(self):
        return self.array.squeeze()
    
    def flatten(self):
        return self.array.flatten()
    
    def toDF(self):
        geoind = []
        geokey = []
        aggind = []
        aggkey = []
        metind = []
        metkey = []
        val = []
        
        for g,a,m in np.ndindex(self.shape):
            geoind.append(g)
            aggind.append(a)
            metind.append(m)
            val.append(self.array[(g,a,m)][1])
            geo, agg, met = self.array[(g,a,m)][0].split(".")
            geokey.append(geo)
            aggkey.append(agg)
            metkey.append(met)
        
        df = pd.DataFrame({ "geolevel_index": geoind,
                            "aggtype_index" : aggind,
                            "metric_index"  : metind,
                            "geolevel_key"  : geokey,
                            "aggtype_key"   : aggkey,
                            "metric_key"    : metkey,
                            "value"   : val })
        
        return df
    

